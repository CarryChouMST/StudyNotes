# 已完成任务与收获

- 夹点基类调整和墙体夹点方案设计与实现，多堵墙的显示，拖动逻辑，墙体datum约束逻辑，高亮/预览中加定位线，处理bug

- 通用消隐方案设计和实现，路径解析、生成、建模，带指针内容数据结构拷贝构造、赋值和析构的设计，提高接口的防护性（去重、过滤）和复用性

- 通用连接框架设计和实现，析构为虚函数（有可能是子类的对象基类的指针在析构），构造为公开非虚函数，基类权限为protected。一些典型需要复用的方法可以抽取一个Helper保证基类的逻辑存粹性。对于有指针作为成员变量的类需要高度注意，从里面拿到的指针的生命周期由谁管理，如果由自己管理，则只开放const获取接口，如果由外部管理，则再内部单开一个指针的set和get接口（或者通过构造函数），保证外部拿到的是拷贝体。

- 在通用连接框架基础上适配非系统构建的默认连接

- Route数据的存储与加载重构，存储时只存储持久化的必要数据与标记，加载时加一层业务解析；在处理数据逻辑时基于对象的思想，比如只存标记，由对象解析标记提供几何；操作数据最好在一个位置操作；在松耦合后需要对数据有较好的封装，某些类的某些方法只为特定对象使用，同时底层封装可以保证基础逻辑的完整，便于后面修改

- 建模错误信息返出，区分系统错误与非系统错误，在做数据时需要考虑到数据的增删改查，即维护的事情，再维护之外，优先需要利用消息中心做好系统下限的保证，即**有效处理非系统错误**。做一项很大的业务时，由于操作来源还是解空间太大，有些东西需要在架构层面手动区分，比如一个东西发生错误后可以做哪些行为，目前规定一定是有一些东西需要被删除（可以为空），不做修改等其他的维护。

- 连接信息维护，在操作中产生的一系列数据最好通过上下文处理，在统一的地方修改数据。在写一段复用率和耦合度比较高的大型业务操作时，考虑添加多个操作策略以灵活应对不同场景下使用的需求

- 连接重构：一套类的体系构建主要是为了可扩展性较强的骨架算法，是模板方法的设计模式；而一套大流程下的高内聚，可复用性比较强的公共方法可以抽取放在一个helper类中，然后在helper中对主体派生体系做一个友元，这样能在类派生体系中更加清晰的看到主体逻辑，实施细节放在helper中；另外helper里面的工具方法为了做一个低耦合高内聚的模式，当输入比较复杂时，需要将其封在一个inputInfo的结构体内，后面外部使用时只需要适配inputInfo就行。同理，在由多个杂乱入口入一个共同的逻辑时，要慢慢将信息收集做抽象，注意做有效的抽象，比如入口可能为当前、已存在的，在执行端接逻辑前，将其适配成基体主路径和支撑体路径等更加抽象，但针对端接逻辑更加直观的概念。总的来说，写一套派生逻辑时，一般要写一个define文件，专门放一些结构定义、写一套派生.h和.cpp文件，写一个放高内聚，可复用的模块逻辑helper，注意方法放在private并加友元，实施严格的权限管理。

- 消隐重构，对于需要由很多自定义的数据结构时，自己抽取一套define逻辑，define文件也可以放一些简单的上下文类，包括get,set方法；写一个接口时，先想这个接口是跟什么相关，如果跟派生体系某个基类强相关，放在里面static，如果是一个从数据结构设计上较为通用的接口，放在server上，写算法先写股价。如果考虑到扩展性，则将其封装为一个模块，以责任链模式注册使用。另外要注意指针生命周期的管理，如果get接口给的是源数据，则加const，不让外部修改，自己管理；如果要放开权限，则注意get和set接口都给出拷贝体。==另外，在写创建时要考虑维护，维护要考虑数据变更有可能有哪些入口，包括操作上的夹点、属性面板、通用命令（重生成代理操作的数据变更），还要考虑到undo/redo系统和保存加载系统时的InOut操作。==

- 非系统构件建模重生成框架：在处理数据时有两个需要区分的概念，一个是负责来处理的对象manager，比如路径的首节点；第二个影响具体要处理的逻辑/对象的信息/对象，比如路径的尾部节点provider。

- modifiedLevel；对于一个事情存在几种不同的模式A, B, C，且ABC之间存在覆盖等级关系，对于这种情况，考虑level的枚举，枚举中定义几个不同的等级，在更新时，高等级可以覆盖低等级。比如在bim业务中，一个obj被修改可以是仅仅为了显示的关系建模修改，可以是有滞后业务的基本建模修改，这种情况下定义一个枚举ModifiedLevel，然后顶一个结构体referenceModifiedMap=是std::unordered_map\<Objectid, modifiedLevel\>，后面不断的upd。

- 更新连接的优化，在n2的复杂度下尽可能的将流程中间数据通过缓存复用优化，将子流程优化至O(n)，写代码要用算法优化意识，提高代码和数据复用率能便于维护和管理，更能提高性能。

- 各种编辑操作下连接和消隐信息的维护，整个重生成是一个以责任链模式组装而成的大处理器处理不同场景下的重生成请求，在代理build时选用在该次请求中涉及到的处理器，并基于StepList装配好每个子处理器且维护处理器间的输入输出关系，有每个子处理器自定义处理逻辑以及输出是否影响整体结果。Db数据只负责存储（持久化，需要唯一定位）和传输，Db数据随业务需求变更由Db数据的代理完成，在Db层只能由Db数据的代理自己操作自己代理的数据。

- 碰撞检测的优化，空间金字塔的建立，以不同的分辨率尺度划分拓扑图形.**首先将碰撞连通图定义为以构件为节点，以构件AABB盒是否碰撞为边的无向图；然后在构件概念的基础上，推广出n阶构件，将其定义为n-1阶构件的碰撞连通图，对应AABB盒则定义为内部所有n-1阶构件AABB的外框；之后基于以上概念构建碰撞金字塔，金字塔中以构件的阶数作为不同层的分辨率。**

- 碰撞检测优化的维护，包括异常情况的处理，undo/redo的适配，跨文档、跨pc端的支持

- 预览重生成错误数据的及时硬/软处理，

- 梁的连接适配

  >  在genActor的查找中，一些根据不同对象的属性有不同的简单逻辑/返出不同的映射对象，这类if else问题，最好将其转变为注册一系列key-value键值被存储，然后将if else逻辑转变为查找逻辑，可以更方便的进行异常定位，和逻辑修改。
  >
  > 上下文面板中使用ContextPanelManagaerImpl单例管理文档中的上下文面板，单例类和全static工具类的区别在于，单例可以存一些私有成员变量表示改单例全局的属性内容，它里面除了防止一些存粹的工具方法之外，还可以做一些**全局实时**数据逻辑的管理与执行，可以把他理解为**作用域受到限制(不导出则只能作用于当前模块)、有规定起始记录时机（初始化）的全局上下文**。

- 多对象共点约束设计，视野要看的与上面的人一样宽，在做东西前还是要线简单写一下骨架流程，这个流程一方面对要做的事情的梳理，另一方面也方便与其他人交流，这个与自己做完后重新整理的详细笔记还不太一样。写东西前先写粗粒度的几个重要part（比如分组信息的存储和维护），然后考虑这些part与哪些数据有关（connection），分别涉及到几个重要的子项（时机，接口/数据结构，维护方式）

- 修改缓存视图路径的结构，定好接口，树本质上就是一个带有成员孩子指针的根节点，可以根据业务需求让这个节点Node类提供一些接口，比如添加孩子，状态管理，在管理的接口中由他去做一些事

  > 在Unified23dDocViewImp中如果在刷ctp中发现当前源ref没有对应的ctpRef，会调用Unified23dDocView的接口同时直接创建createCounterpart和reference，因此在ctp中目前DO没有得到复用，另外，在create之前会调用atom的shouldCreate接口，因此可以走创建接口但不创建东西，在外面后续刷ctp中，如果ctpId为空，则表示不需要副本显示，返回ok就行。因此在写一个抽象的大流程时，流程中可以有一些check和should接口，后续的流程要注意上一个流程下某些结果为空的问题。

- 类的概念要清晰一些，类要清晰知道类的方法是谁在用，有一些方法的对象属性比较重，放在类的成员方法里面，比如topo里面算step的权重；有些方法的上下文属性、工具属性比较重，有很多相关的/非派生的对象都在用，将其放在工具方法里面。

- clean方法主要要注意两个方面：一是指针生命周期的释放；二是容器的清空。、

- 消隐ctp的mdb适配和重构，如果有一个接口传Id穿不进去（因为id不能被重复打开），尝试传Id下的某个模板的代理管理器，比如atom很重，为了突出骨架算法，封住细节，底下有一个ctpUpdManager，mgr自己又带有updCtx和pfmctx接口。

- 重构db
  - 做事情要对象化，粗粒度化，如果一个事情比如建模，给定一个输入后，有很多依赖于这个输入的特有逻辑，就包装一个特有的上下文来做这个事，外界感知不到里面的事。**接口隔离原则(ISP)**，和**迪米特法则(LOD)（**对象应当对其他对象尽可能少的了解
  - 各个模块之间相互调用时，通常会提供一个统一的接口来实现**）**
  - 有一些内部核心数据结构只是为了帮助上层来管理特有的数据，里面只写set和get接口，数据逻辑的组装全部由上层来组装，底下提供接口读写数据，上层真正的管理这些数据的用途，比如element用来记录数据，ctpAtom用来显示数据。
  - C++的封装特性，将类对象化，关注外部视角下类的表现；可以有一个专门的数据管理类，内部方法类，和外部公开方法类；在底层封db读写接口，上层写逻辑组装。
  - 对于内核数据如driver，有很多上层结构再用，但又不想过于暴露，中间可以通过工具类的方式加一层数据逻辑组装层，各个上层结构用的时候，通过数据逻辑组装层用，不要接触到里面。

- Db一般用于对象的持久化数据缓存，该缓存存在于整个Db模块的生命周期；有时需要在一次业务范围内缓存一些query和match数据，可以构建了一个单例对数据进行管理（单例实际上是限制作用域的全局上下文），并提供clear方法，在一次业务结束后调clear方法清除掉缓存的业务查询数据。

- 对于数据相互依赖的匹配逻辑，如果是该匹配逻辑完全与类型相关，才直接使用虚接口赋予子类完全的控制权；如果有些概念与类型无关，可以抽象为系统枚举标记，尽量抽象为系统标记，在虚接口的上下文中传入该标记（或者是在基类中解析），那在基类中就能把事情干完。

- 线性构件逻辑对象，行为和id的抽象

  > 对于一个抽象层级较高的类，比如线性构件，可以在里面做一个私有数据管理类，在该数据管理类中只提供get, set方法。然后对外有一个Util/Helper/或者其他类处理线式的数据逻辑，在里面中，涉及到复杂的创建过程（或者容易变化的东西），可以使用工厂类进行封装。
  >
  > ==工厂/manager(可能要缓存)创建$\to$对外的业务逻辑类（可以是一个抽象逻辑上的Helper/Util，也可以是一个具体的对外对象）$\to$私有的数据管理类== 
  >
  > 在进行数据设计时要分层设计，每层在对外类中提供给上一层看到的内容，可以是类的组合（墙与线性构件），或者某个抽象层次的类（element）。
  >
  > 有新的需求进来时，判断场景入口，如果入口很多，且过于业务不适合放在生成kernel层，则在出口connectionActor执行逻辑满足需求。

- 线性构件容差功能嵌入到连接框架

- 非系统构件约束流程设计

- 兼顾用户意图与系统推断的自动点约束构建流程

- 梁上下文面板命令类型切换不成功调试。

  > - 在画类的UML图时，可以使用虚线空箭头标识类的==继承关系==，使用实线标识类的==生产关系==
  > - 通过工厂/Creator/Manager进行复杂对象的创建，将对象的创建和功能实现解耦。如果有派生复用的需求，在工厂/Creator/Manager的基类基于不同的标识符进行统一注册(或者RTTI反射)便于管理。manager/工厂等可以提供注册方法，然后将已注册的内容放到自身的成员变量进行管理。

- 调试创建/编辑workFlowJob进入时的上下文面板根据选择集的显示和不显示区别，有些接口（比如面板的startUp）是一个公共的工具接口，接口里面的内容是一个高复用的逻辑，在要修改接口内内容时，首先要想到是不是直接属于这个接口代表的概念，如果是上下文业务上的概念(比如根据选择集判断要不要唤起)，优先考虑在接口外面做，因为调这种工具接口的地方会有很多，不是所有的东西都有这个概念，而且有的地方可能会有冲突的（比如就是要选择集大于1才能进入），handler是外界定制化该接口的途径之一，但是handler本身也是复用率比较高的，对于比较独立的业务需求，应该在最开始这个接口的位置就体现出这个差别。

- 纯虚函数一般只有一个位置调。

- 【将约束放到连接维护框架】要基于产品的业务常见和总体架构设计，根据复用频率和依赖关系积极做分层依赖和dll拆分，进而将代码松耦合，有较强的扩展性。比如在前后端分离下，需要有一层后端数据库pcdb，表示不依赖于客户端的纯数据；在客户端内存上做业务时，需要有一个内存持久化数据BmDatabase；考虑到持久化数据为了存储对数据做了很多拆分、优化、复用，在做业务时需要有与业务语义更相关的数据，因此诞生了docItem，viewItem等item代理数据层，他们两个没有太多的关系，因此拆成了两个dll。现在是考虑到文档数据中有一些通用业务需要维护，因此在doc和docitem之间可以做一个connectionActor层。

- 【重构多对象共点约束】【层间架构思考】怎么定义逻辑属于数据上的，还是属于文档上业务

  - 对于一个发布后的产品，在修改持久化数据时一定要注意版本控制，后一个版本的逻辑要能兼容前一个版本的数据，具体来说，可以给一些默认值等。比如在connection中添加了一些属性，在使用该属性的代码中需要给该属性添加一个老数据能使用的默认值。

  - > - 首先逻辑都是由需求定义的，数据可被区分为持久化数据(pcdb)和内存临时数据(itemDb等)，两种数据在内存架构中都称为数据。
    >
    > - 数据本身会根据自身的概念提供一些小颗粒度能力（比如get/set接口），在对外接口中也可以做一些更大颗粒度的封装（比如一些server等微服务），对于一些非常大的能力，为了保证其灵活性提供一些上下文标记，但是不会脱离其数据的概念，本质上是提供一种能力。==另外数据间的协同也是一种能力==
    > - 来一个需求后，一般需求逻辑都是通过文档业务逻辑对需求解析适配后，组装数据层提供的能力接口（调一个大接口给上下文标记也行/调不同的小接口服务也行）。
    > - 所谓纯数据逻辑就是需求中需要由业务解析的内容比较少，直接使用数据提供的某种颗粒度能力就能满足需求。
    > - 判断一个逻辑属于业务还是数据首先就看这种逻辑是不是一种通用能力，如果是通用能力就由数据提供，如果是当前需求需要的特定效果就在文档业务层组装数据接口。
    > - 持久化数据为了优化持久化性能会对数据做一些拆分和重组，在内存中执行逻辑时可以做一个新的代理层，也就是docItem，可以让docItem提供一些能力。

- 【构件加载更新调试】写业务逻辑代码时，不仅要考虑业务场景下逻辑的松耦合分层设计；更要考虑产品整体数据架构云边端的设计，对于非系统构件这种开放给用户的，做成一个高内聚的设计，同时对于非系统构件内部的私有属性、表达数据，尽量不要记录在设计上记录构件之外的信息，因为不知道用户会在里面做什么，也就无法修复，直接替换。

- 【夹点以及交互editor的设计思考】对于外观模式的使用，外观类提供非核心，语义更强，对外可见的逻辑和变量；核心逻辑以及变量，可以单独做一个impl类进行管理。然后在外观类的构造函数中new其实现类，析构函数中释放。这样用不同的类管理也便于面向对象的理解逻辑组成。

- 【约束适配到框架】==做事情优先从抽象的方式做，做完了在性能优化阶段中再考虑性能和扩展性的平衡==。难点：需要在各种场景下建立合适的约束，需要识别对应的场景，参与关系的构件/非构件（纯几何）【在关系中只有几何没有构件的概念，需要理清构件业务接口和纯几何接口，比如现在有一个逻辑几何，要去拿逻辑几何上有没有其他的关系，这个应该脱离了构件的概念，需要几何上的接口。但是目前线性构件是在构件上做了抽象，还没有抽象到几何级】，匹配关系的类型。

- 数据直接修改接口（为了数据的提供），内部模块组装imp，外部语义接口（为了模块的封装，模块内和模块外得到的信息不一样）

- 【带团队与沟通】让成员自己单独推进事项，独立负责

  - 自己有精力处理困难的任务，帮助团队获得更多的资源
  -  通过独立负责锻炼成员的全流程解决能力
  - 通过独立沟通与汇报帮助成员在+2领导有更多的表现机会，+2领导可以更好的把握人员情况
  - 拿到需求，首先需要对需求做评估，从五个方面：需求的必要性（描述场景）、正确性（是否和架构目标匹配，前后端分离...）、合理性（交付时间下，是否出现研发团队和动作完全变形的情况）、可达性、承接方（有没有团队能承接、愿意承接）（必正合可乘）
  - 然后对需求做需求分析：理解业务（没有歧义的拆分各个功能点），识别重难点业务，识别非功能需求和质量约束（比如性能，扩展性，可靠度），给出基本业务架构

- 【带团队】要因材施教，把人放在合适的位置。有些人汇报能力、信息整合能力比较弱，但是喜欢钻研，就主要安排一些具体的算法任务；有些人沟通能力较强，主要负责一些协调工作。高意愿，低能力，给足情绪价值和指导，但能力还需要提升；低意愿，高能力，放养。对于沟通能力不算强，能钻研的多帮他把控进度，弱看实现；对于善于汇报，能力不足的多看实现。

- 所谓带团队，就是充分发挥手下人的能力，帮他们补足不足的，在保证自己能最小粒度的维护存量工作同时，最后自己做一些开拓性的事务，增强团队力量。对于沟通能力较强，有能力的人，给锻炼机会。==另外，做开拓性事务之后，继续把后续维护分发，保证自己对于管辖内业务模块都有较为深刻的理解，但不必了解实现细节bug。==

  - 对于想法很多，正确/不正确都有，比较坚持不太听指挥，但是初步能力不太够的，引导他自己把想法成型找我评估，问为什么/怎么做，但不负责给方案；后期可以让他分为初步评估和详细评估，初步评估不要那么坚持。
  - 喜欢过早下结论时，问结论依据，问依据可靠度。
  - 当团队处理过多时，要及时分权，然后做个统计数据（基于过滤器做JIRA进度表等）定期观察，遇到有感兴趣的内容主动了解，如此能够让团队高效的运转。顾住了效率，如何把控团队产出的质量？对于大面积修改的任务类型，有限放权，采取口头分任务的方式驱动团队运转，最后个人把控质量。

- 【调试、运维、工具和脚本能力】大型项目的模块调试、松耦合（载入代码）调试和附加进程等调试经验，编写批处理、python脚本处理工程部署的运维和调试需求，比如在release下写脚本批量关闭所有模块优化后，高速调试等。

- 【db数据的优化】广义的生命周期包括对象生命周期、权限管理、版本控制、状态流转等，可以通过策略进行配置。一个db主要是为了更好的管理对象的生命周期，而要将数据持久化，需要后端提供IO流接口，不一定所有的db数据都需要被持久化。

- 【预览机制的优化】可以通过线程同步的方式，实现流程间的通信，对于一些高复杂度操作优化体验时，可以做个简易版，然后以异步的方式做一个完整版，可以实时根据操作频率优化体验

- 【预览优化对于构件的适配】在前后端分离的C/S架构模式中，**前后端的数据流转方式**对项目产品整体性能很重要，一般是是**通过数据对象链接的方式，实现按需的加载/卸载**，这样能减少C端的内存压力和负载，将构件实例、构件类型模板、类型定义数据作为不同层级的数据对象，不同环境下编辑不同层级的对象（比如构件定义环境编辑数据定义对象，构件编辑器环境编辑模板数据，项目环境编辑实例数据）。不同层级的数据都被聚合于文档根对象中，后端将根对象加载。==另外，对于链接/加载，也便于区分数据层级，灵活的在不同层级上复用、定制数据==

  数据的链接复用有以下好处：

  - **内存效率**
    - **减少冗余数据**：通过链接，多个对象可以共享同一个数据对象，避免了数据的重复存储。
    - **延迟加载**：可以只在需要时才加载和初始化数据对象，节省内存。

  - **提高性能**
- **快速访问**：通过指针或引用可以快速访问关联的数据对象，而不需要进行复杂的查找或复制操作。
  
- **节省处理时间**：避免了不必要的数据复制操作，可以显著提高程序的运行速度。


  -  **更好的可扩展性**
    - **动态修改**：可以动态地添加、删除或修改数据对象及其链接关系，而不需要重新分配和复制大量数据。
    - **模块化设计**：数据对象的链接方式支持模块化设计，使得程序的结构更加清晰，易于维护和扩展。
  - **数据一致性**
    - **共享更新**：当数据对象被多个地方引用时，更新其中一个对象的数据，所有引用该对象的地方都会同步更新，保持数据一致性。
    - **集中管理**：可以集中管理和控制数据对象的生命周期和状态，减少数据不一致的问题。
  - **增强灵活性**

    - **多态性和继承**：在面向对象编程中，通过基类指针或引用，可以实现多态性，处理不同类型的对象而无需知道它们的具体类型。

    - **松耦合**：对象之间通过链接进行通信和交互，而不是直接依赖于具体的实现，使得系统更具灵活性和可维护性。
- 【重生成执行流程梳理，性能优化】如果软件运行时间长后出现明显的卡顿，考虑内存泄露。另外有可能是由于运行时间长后，系统中内存分布趋向碎片化，难以找到整块内存（查找时间）。
  - 另外对于有向图中如果边的数量远高于节点的数量，同时有频繁的查询递归查询需求，可以考虑加密算法的思想，将查找待执行边解析为有向图中连通分量的状态，将有向图的连通分量状态进行缓存维护，从而将递归查询需求映射为整块分量。
  - 对于有向图中的执行流，流向节点时，一般需要做 刷新依赖$\to$执行自身$\to$状态广播 三件事，考虑到执行时存在较多的重复子树查询，采用动态规划的思想，将查询需求分解为查询各个根节点下的生成子树生成状态。
-  【性能优化】实现细节，负载均衡
-  【重生成图的构建与维护】
-  【大型项目数据模块接口运行数据的排查】打log
-  【方案设计】流程图与关键点详细方案，类图与接口设计，关键接口调用与封装
-  一般工厂方法+建造者模式适用于构建复杂初始化对象，同时将建造者映射为简单的id放置于管理器中，可以建造不同初始化方式的相似对象。**对象具有资源和行为，当资源的初始化过于复杂，可以用建造者。但行为最好统一。因为资源初始化一定是程度上表示实现注入，但是行为是对象固有的，理解为接口依赖。基于依赖倒置原则， 在修改时，应该修改注入实现而非接口依赖/行为。**
-  在协议绑定时，可选有轮询和直接映射两种方式，后者直观且性能友好，但是灵活度不够，需要对于不同对象都映射为唯一的key【也可以直接用名字，那就在解析上下文时映射，一般比较简单的解析就在上下文解析好后直接映射】。对于同类型对象不同上下文下【复杂的解析行为可以还是用轮询】需要有不同**类型**的行为模式还是用轮询的方法。**协议只代指行为，协议的行为最好是统一的。即创建协议可以有上下文进行扩展，但是协议的动作最好是明确的参数。**但有时确实需要基于上下文赋予不同的行为，比如step，但最好是相同的i行为类型，即流程相同，实现不同。
-  绑定协议时想好该协议的使用方是不是仅在当前，如果只在当前，就可以帮一个特有的对象或者直接轮询。如果不是，考虑协议绑定见绑定一个基础对象，或者针对特有对象有一个基础的创建方法。
-  【外观模式，实现注入，实现类崩溃，Debug】如果使用外观模式，外观类提供接口规定交互方式（供内部依赖），需要基于构造/接口/配置等方式注入依赖实现，此时需要注意如果使用构造注入的话，每个外观类都要定义自己的依赖注入（不然实现类就是老的实现类）。
-  【外观模式】第一个使用外观模式的基类，一般要声明一个直接由注入类作为构造参数的构造函数。另外声明一个默认构造函数，实现写上默认的注入类。这样派生类实现时，就会在自己的默认构造函数中，以自己的注入类作为参数传给基类的带参构造函数。
-  【Debug，上下文Context，上下文参数】在一个大流程中有输入参数，输出参数和上下文参数，其中上下文参数是大流程中子流程通信作用的工具，最好可以用一些基础类型维护，这样在头文件中可以不用暴露太多的实现，比如可以用一个键值（String，Variant）维护，也可以用指针维护。**需要注意的是如果里面放指针，要注意生命周期托管的问题，生命周期管理在流程内，外部ctx进行拷贝或者等号赋值时注意提前清空上下文参数（或者做可控处理），不然可能会发生野指针析构崩溃！**

- 【函数成员变量，回调变量】如果对一个封闭逻辑希望有默认处理同时提供定制方式，可以让对象持有一个函数成员变量，同时在对象中有一个函数成员作为默认值，并在构造函数中将该函数成员基于std::bind绑定到成员变量中。
