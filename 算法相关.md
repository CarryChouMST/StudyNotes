- ![image-20230410190933944](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20230410190933944.png)

- 向量叉乘得出的结果是一个向量，其方向垂直于叉乘向量的平面，对于二维向量叉乘，可视为z向为0，则叉乘结果为0,0,z式的向量，然后可以通过z的正负判断点在直线的方位。

- A向量与B向量的叉乘AxB(A在前)，其方向为右手定则从A到B，大拇指的方向。

- 快速判断两个凸包面是否碰撞的方法，可以采用轴分离算法，具体细节如下

  ![image-20240328164602875](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240328164602875.png)

  ![image-20240328164520643](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240328164520643.png)

- 轴对齐BoundingBox和方向boundingBox![image-20240328165454412](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240328165454412.png)

  综上，分离轴定理是一种适用于 bounding box 和 polygon 的精细碰撞检测算法，其优点是算法原理简单，可准确判断两个多边形是否相交；缺点在于当多边形的边数较多时，该算法的效率较低（当两个多边形相交时，需要遍历完所有边进行判断）。

  在实际应用中，为了提高效率，通常**先使用 基于轴对齐包围矩形（AABB）的方法进行粗略的碰撞检测，然后再使用 分离轴定理（SAT）做精细碰撞检测**。

# 编码算法经验

- array与unordered_map，unordered_map基于键值对的删改查中有优势，尤其是查和删和改，**但是对于增，unordered_map需要做一次额外的hash，会耗费比较多的资源**

  ==同时如果数据对于遍历的需求比较高，修改也是批量修改而不是单点删，改，使用array会有较大的优势。因为unordered_map由于hash算法的映射会占用较多的空间，而且也带来遍历性能的损耗。==

- 相比于for循环，while循环比较动态，可以用于动态区间的循环/分段处理。比如如下：

  ~~~cpp
  std::priority_queue<int> Q;
  while (!Q.isEmpty())
  {
      auto cur = Q.pop();
      for (const auto it : cur)
      {
          ...
      }
  }  // 以上就实现了bfs的基本模板代码
  ~~~


- 并查集union-find需要有一个图边的数组以及根节点映射表，根节点映射表中的各个节点初始化为自己，然后基于该表定义join与find方法。 

# 容器

## 区间信息/区间查询

### topk数集

- 全排序O(n(log(n)))

- 部分排序(O(nk))

- 只取部分不排序，维护小根堆/大根堆O(n(log(k)))

- 随机选择，减治法，O(n)

  快排伪代码

  ~~~cpp
  void q_sort(std::array<int> nums, int low, int high)
  {
      if (low >= high)
      {
          return;
      }
      
      int i = partition(arr, low, high);
      q_sort(nums, low, i-1);
      q_sort(nums, i + 1, high);
  }
  ~~~

  



# 图论算法

## 最小生成树

### Kruskal算法

- 并查集时间复杂度|==反函数，就是对于值应用相同的函数，得到定义域。即未知量和值调换一下==

  同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\alpha(n))$，其$\alpha(n)$ 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。

  [Ackermann 函数](https://en.wikipedia.org/wiki/Ackermann_function) ![A(m, n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的定义是这样的：

  ![image-20240621101908203](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240621101908203.png)

  而反 Ackermann 函数$\alpha(n)$的定义是阿克曼函数的反函数，即为最大的整数m使得$A(m, m) \leq n$ 。增长及其缓慢，一般不大于4。

另一种定义方法：**阿克曼反函数-----选定一个值下，结果大于该值的最小参数。**![image-20240621102920916](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240621102920916.png)

- 因此，整个并查集的时间复杂度在使用路径压缩和启发式合并后，时间复杂度为$O(m\alpha(n))$，其中m为边数（操作数），n为节点数。
- 并查集除了可以用路径压缩法优化外，还可以用按秩合并法优化。按秩合并就是在对两个不同子集连接时，按照rank来连，也就是rank低的连在rank高的下面。rank高的做父亲节点，这样类似维护了一棵树，树是rank高的在上。因为路径压缩法优化程度更高，所以一般情况下使用路径压缩法。但是路径压缩法会破坏树的结构，在不想破坏树的结构的情况下，可以使用按秩合并法。
