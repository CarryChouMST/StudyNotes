# 经典命名

- Asset：资产，在git的发行页面中常见。

# 其他描述

- 工厂方法模式是对简单工厂模式进行了抽象。有一个抽象的Factory类（可以是抽象类和接口），这个类将不在负责具体的产品生产，==而是只制定一些规范，具体的生产工作由其子类去完成。==|**类的单一职责，有人负责指定规范，有人负责具体生产。**|**（规范即为生成流程，类似于算法骨架，模板模式）**


- 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。|==**算法执行细节的延迟反射。**==

- ==我们掌握一种思想，就是在创建一个对象时，需要把**容易发生变化的地方给封装起来**，来控制变化（哪里变化，封装哪里），以适应客户的变动，项目的扩展。==

- ~~在类间的依赖，或者排图的节点依赖时，尽量做到只有层间的依赖，尽量不要做层内的依赖，对于BIM项目而言，modify可以去依赖很多的base都没有问题，只要不依赖modify就行。约束也是通过driven和driver的方式将connection之间的step依赖变为了层间的依赖。~~

- 重读闭音节才需要双写，*begin的音标*：英[bɪˈgɪn] 美[ˈbeɡɪn]后面gin重读，这是一个闭音节，两个辅音夹一个元音，后面的辅音不能为r, w, y。**而open的音标为英[ˈəʊpən] 美[ˈoʊpən] ，重读为open，重读部分为双音节。因此不能双写n。**

- 如果是你想把对象的生命周期托管给这个容器，你就给写权限，如果明确不接管，那就只给const的进来，明确读写权限，否则外面需要读你的实现才知道要不要释放。

- 数据抽象，要保证接口独立于实现，即为松耦合。具体来说，==使用接口的方法或者类不需要根据接口的具体实现而调整自身的业务代码，保证接口的功能和名字统一==。

- 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。有两个重要的优势：

  - 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
  - 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。

- 异步执行，在做一些事时将信息都收集起来打成闭包，被需要的地方在执行，嵌入其他的流程里面，闭包并不知道执行的时机。

- 数据提供服务与能力，业务根据需求效果组装数据提供的服务。

- **volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改**，比如：操作系统、硬件或者其它线程等。==volatile 可以保证对特殊地址的稳定访问，一般用于可被外部硬件端口映射的内存访问。C++中不含并行语义（缺少原子性与内存序保证），但是在Rust等语言中有。==

- C++架构中的类可以分为能力类与调度类，能力类处理实现细节，调度类把控底层流程。

- 分发器Dispatcher->调度器Scheduler->执行者executer

- 连通图：在无向图中，若任意两个顶点$v_i$与$v_j$都有路径相通，则称该无向图为连通图。
  强连通图：在有向图中，若任意两个顶点$v_i$与$v_j$都有路径相通，则称该有向图为强连通图。
  连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。
  生成树：**一个连通图的生成树是指一个连通子图**，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。
  最小生成树：==在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。==

- C++设计原则：

  - 单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
  - 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
  - 里氏代换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象，比如我喜欢吃水果，那我一定喜欢吃苹果。
  - 依赖倒转原则(Dependency Inversion Principle, DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
  - 接口隔离原则(Interface Segregation Principle, ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
  - 优先使用对象组合，而不是类继承；类继承为“白箱复用”，对象组合为“黑箱复用” 。
  - 封装变化点
  - 针对接口编程

- **全序关系**，也称为**线性顺序**（英语：Total order, linear order）即集合x上的反对称的、传递的和完全的二元关系（一般称其为≤)。

  若𝑋满足全序关系，则下列陈述对于𝑋中的所有𝑎,𝑏和𝑐成立：

  - 反对称性：若𝑎≤𝑏且𝑏≤𝑎则𝑎=𝑏
  - 传递性：若𝑎≤𝑏且𝑏≤𝑐则𝑎≤𝑐
  - 完全性：𝑎≤𝑏或𝑏≤𝑎

  满足全序关系的集合叫做**全序集合**、**线性序集合**、**简单序集合**或**链**。 **链**还常用来描述[偏序集合](https://zh.wikipedia.org/wiki/偏序集合)的全序子集。

  良序集合的排序方式，使得我们可以逐次考虑一个它的元素，而在还没有检视完所有的元素的任何时候，总是有一个唯一的*下一个*元素可考虑。

- 这里先介绍**“秩”**的概念。我们定义一棵**二叉树**的秩为从为**从根节点开始**到**其叶节点**中**最长的一条树链**上结点的个数。
  对于空结点𝑛𝑖𝑙，它的秩为0。对于一个没有孩子节点的根节点，秩为1，一般地，那么对于任意非空节点𝑥，它的秩可以如下定义：`𝑥.rank=max⁡{𝑥.left.rank,𝑥.right.rank}+1`
  
- 在向量、列表、栈和队列结构中，元素都存在一个自然的线性次序，所以它们均属于线性结构(linear structure)。树则不然，其中的元素之间并不存在天然的直接后继或者直接前驱关系，但只要附加某种约束(比如遍历)，也可以在树中的元素确定某种线性次序，因此树属于半线性结构(semi-linear structure), **关联式容器**。**树是一种分层结构，而层次化这一特征几乎蕴含于所有事物及其联系当中，成为其本质属性之一。作为树的特例，二叉树实际上并不失其一般性，无论是逻辑结构还是算法功能，任何有根有序的多叉树，都可等价地转化并实现为二叉树。**
