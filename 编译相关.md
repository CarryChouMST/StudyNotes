# 头文件与库文件

## 一、头文件

在编译过程中，代码一般被拆成很多部分，每部分被放在一个独立源文件中。比如程序中有两个函数main()和abc()。main()函数位于main.cpp，abc()函数位于abc.cpp，main()函数中调用abc()函数。在编译阶段，由于编译是对单个文件进行编译，所以编译main.cpp时，编译器不知道是否存在abc()函数以及abc()调用是否正确，因此**需要头文件辅助**。

**总的来说，编译器不知道abc的用法是否正确，只有借助头文件中的函数声明来判断，对main.cpp进行编译时，不会设计abc.cpp文件，只会设计main.cpp和abc.h（被include）文件**

## 二、库文件

库文件中包含一系列的子程序。例如abc.cpp源文件中实现了abc()函数，我们需要将abc()函数提供给客户使用，但是不希望客户看到算法源代码。因此我们可以将abc.cpp编译成库文件，**库文件是二进制的**，在库文件中是看不到原始的源代码的。库和可执行文件的区别是，**==库不是独立程序，他们是向其他程序提供服务的代码==**。当然使用库文件的好处不仅仅是对源代码进行保密，使用库文件还可以减少重复编译的时间，增强程序的模块化。将库文件连接到程序中，**有两种方式，一种是静态链接库，另一种是动态链接库。**

==**简单来说，库文件通过头文件向外导出接口，用户通过头文件找到库文件。**==

# dll与lib

很多人认为lib为静态库，dll为动态库，这理解并不错，但不全面。lib其实分两种的：

第一种， lib是完整的静态库，里面有函数代码本身，在编译时直接将代码加入程序当中，应用程序直接使用
第二种，**lib是动态库的导出声明，只包含头部信息**。是dll在编译、链接成功之后生成的文件，作用是当其他应用程序调用dll时，需要将该文件引入应用程序里面只有**函数所在的DLL文件和文件中函数位置的入口**，代码由运行时加载在进程空间中的DLL提供

# \__declspec(dllimport)与\_\_declspec(dllexport)

- 为便于表述，现using IMP = \_\_declspec(dllimport)；using EXP = \_\_declspec(dllexport)
- EXP声明一个导出函数/变量，这个函数/变量可以从本DLL导出。意思是在dll外部可以使用这个函数，这种声明形式一般出现在dll的头文件中。
- IMP声明一个导入函数/变量，表明这个函数/变量是从别的DLL导入的，我要在本文件中使用。一般用于需要使用外部dll中某些函数/变量的exe工程头文件中。
- 换句话说，对于一个跨工程文件，他的头文件既要被本工程定义的函数包含，也要被其他工程使用到该文件的函数包含。但是由于使用场景不同，该文件的作用也不一样。==对于本工程定义的函数，他要使用EXP声明自己是要导出的函数/类，在dll外部也可以使用我；对于在其他要使用他的工程而言，其他工程需要知道该函数/类是一个由其他dll导入的，我要在本dll使用。==**注意，不使用 \_\_declspec(dllimport) 也能正确编译代码，但是不能基于定位查找对面dll中的内容，只能使用包含的头文件。同时使用 __declspec(dllimport) 使编译器可以生成更好的代码。编译器之所以能够生成更好的代码，是因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨 DLL 边界的函数调用中。但是，必须使用 __declspec(dllimport) 才能导入 DLL 中使用的变量。**
- 但是，如果使用2个头文件，这2个头文件的大部分内容是重复的，只是一个是\_\_declspec(dllexport)，另一个是\_\_declspec(dllimport)。而且，如果改动一个头文件，另一个也要做相应的改动。这样就带来了极大的不便，那么，如果使用了宏，就可以将2个头文件合二为一，使用同一个头文件即可，在不同的环境下使用不同的代码段。

# 编译、构建、生成、翻译单元等名词

- ```
  compile的作用是对你的代码进行语法检查，将你的文本程序语言转化成计算机可以运行的“01010....”形式的二进制文件。compile过程生成“.obj”文件或".o"文件，这个和编译器有关，vc++中是“.obj”文件。
  在compile完成后，会执行link。link是将obj文件链接起来，并检查它们是否具备真正可执行的条件。 如果检查通过，则将obj文件链接为exe或dll文件
  ```

- 构建，build/生成：先把工程中所有源代码编译度成目标文件，再link链接成[可执行文件](https://so.csdn.net/so/search?q=可执行文件&spm=1001.2101.3001.7020)（或者lib、dll，看具体工程）。这其中，如果有源文件在此之前知被单独编译过，这个文件就不参加编译，它之前编译时产生的目标文件参加link（链接）过程。即两个一起做。

- 翻译单元（Translation Unit）

  - 一个翻译单元包括**一个源文件、源文件直接或间接包含的所有头文件**，当编译器处理一个源文件时，它会将

- 在VS中，有如下层级：

  - **翻译单元**：包括一个源文件，以及源文件直接或间接包含的所有头文件
  - **项目**：一个或多个源文件的集合，通常是用来组织和管理代码的单元。在 Visual Studio 中，项目通常代表一个==可执行文件、库文件或者其他类型==的软件模块。**项目可以包含多个源文件（如 C++ 源文件、头文件、资源文件等），以及项目配置、依赖项等信息【一般形成了他的vcxproj文件】**,这些信息以xml文件组织，**优化选项在ItemDefinitionGroup下的AdditionalOptions（命令行提供优化指令-O1/O2/Od）或者Optimization（VS交互面板选择优化手段）中**。
  - **解决方案**：一个由多个项目组成的可执行文件通常被称为**解决方案**，解决方案是包含一个或多个项目的容器，solution提供了一个工作区，可以同时管理多个项目，并在这些项目之间共享资源、配置和设置。在一个解决方案中，通常会包含一个主项目（例如一个可执行文件或一个库文件项目），以及一些辅助项目（例如测试项目、工具项目等）。
  - **平台/系统**：在大型平台项目管理中，一般一个仓库管理了一个解决方案。系统的构建和维护可以通过多个解决方案来分解和组织，这有助于提高代码的可维护性和可扩展性。每个解决方案可以独立地开发、测试和部署，同时可以通过共享资源和接口来实现系统整体的一致性和协作。

- **release调试**：release模式本质上是一些编译配置，要在release下调试问题，可以将优化全部去掉。注意优化选项一般以项目为粒度，要批量处理所有项目的优化选项可以写个批处理脚本。

# 编译优化

- 传统的编译器通常分为三个部分，前端(frontEnd)，优化器(Optimizer)和后端(backEnd)。在编译过程中，前端主要负责词法和语法分析，将源代码转化为抽象语法树；优化器则是在前端的基础上，对得到的中间代码进行优化，使代码更加高效；后端则是将已经优化的中间代码转化为针对各自平台的机器代码。

- ![image-20240523102034823](C:\Users\CARRYCHOU\AppData\Roaming\Typora\typora-user-images\image-20240523102034823.png)

- 编译器

  -  GCC（GNU Compiler Collection，GNU编译器套装），是一套由 GNU 开发的编程语言编译器。GCC 原名为 GNU C 语言编译器，因为它原本只能处理 C语言。GCC 快速演进，变得可处理 C++、Fortran、Pascal、Objective-C、Java, 以及 Ada 等他语言。
  - LLVM (Low Level Virtual Machine，底层虚拟机) 提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种编译器的后台来使用。
  - Clang 是LLVM的前端，可以用来编译C，C++，ObjectiveC等语言。Clang是以LLVM为后端的一款高效易用，并且与IDE 结合很好的编译前端。
  
- 

  

# 常见编译错误原因

- 缺少类型说明符 -假定为Int。注意C++不支持默认int

  - （此情况经常出现在大型工程项目中）如果存在两个类的头文件a.h和b.h,在a.h中有这样的语句：#include"b.h",在b.h文件中有这样的语句：#include "a.h"且在一个类中有另一个类的对象时，那么就会出现这样的错误。
  - 没有包含要定义的类的头文件。
  - 项目中少加了宏定义，导致头文件重复定义或相应宏无法识别。
  - 当有多个头文件时，顺序写反也可能导致相关的错误，其根本是头文件中的预编译语句被隐去了。
  - 可能是函数没有写返回值

- C++生成解决方案报错可能由上面的错误导致下面的错误，直接看最上面的错误是怎么造成就行

- c++编译错误-- C2678 二进制“=”: 没有找到接受“_Ty”类型的左操作数的运算符(或没有可接受的转换)

  ==一般是在排序或者赋值的时候，对一个const变量执行了操作，好好检查所有的排序，map赋值（此时的map需要是非const的）等。==

- error LNK2001： unresolved external symbol...，一般是引用的某个类在cpp中使用时，有其他动态库对应的lib文件没有被链接上，需要检查CMAKE的LINK_LIBRARIES类似变量。

  **如果确认CMAKE引用了，而且方法报的都是同一个类无法解析，那还有可能是该类没有被声明为导出，注意内部类不只外围类要导出，内部类自己也要设置导出。**

- fatal error C1083：不能打开include file...(compile source file ...), 基本是某个类所在模块的include文件没有cmake链接不能找到，不能单看当前正在编译的文件，同时要看正在编译的模块所依赖的其他模块是不是也因为各种原因没有找到该文件。

- 一个导出类的static const成员，必须在cpp文件中使用构造函数进行初始化，这样才能导出，不然会报unresolve externak symbol的错误。

- error C3848:  具有类型“const _Hasher”的表达式会丢失一些const, volatile标识符。 

  hash函数的原型如下，有限定符const，编译时，由于hash_name 重载操作符‘（）’未加const函数限定符（函数只读限定），导致不匹配，编译时检测出错误，可以将hash_name改为

  ~~~cpp
  size_t operator()(const _Kty& _Keyval) const
  		{	// hash _Keyval to size_t value
  		return ((size_t)_Gethash()(_Keyval));
  		}
  ~~~

- 【模板元编程】error C2275: illegal use of this type as an expression。这个错误通常发生在你试图在需要一个值的地方使用类型，或者在不恰当的上下文中使用类型时。假设你有如下代码：

  ```cpp
  convertStringToKey<T::key_type>(key);
  ```

  可能的问题：

  1. **模板类型名称不明确**:
     - 如果 `T` 是一个模板参数，`T::key_type` 需要被解析为一个类型。但如果 `T::key_type` 是一个依赖于模板参数的类型（即 `key_type` 是 `T` 的成员类型），编译器在第一次解析模板时不知道 `T::key_type` 是一个类型，而是把它当作一个值来看待，因此会导致错误。
  2. **缺少 `typename` 关键字**:
     - 当你在模板中使用依赖于模板参数的嵌套类型（如 `T::key_type`）时，你需要使用 `typename` 关键字来告诉编译器这是一个类型，而不是一个静态成员或变量。

- 【模板元编程】模板是编译时机制，编译器需要在模板实例化时看到完整的模板实现。如果模板的实现隐藏在DLL中，编译器就无法实例化它。

- 【错误，无法识别的类空间或命名名称】如果确认头文件确实包含了，那么有可能是头文件之间循环包含的问题，需要尝试解环，一般可以基于前置声明等手段。

# pdb文件

- PDB（Program Data Base），意即程序的基本数据，是VS编译链接时生成的文件。pdb文件主要存储了VS调试程序时所需要的基本信息，主要包括源文件名、变量名、函数名、FPO(帧指针)、对应的行号等等。因为存储的是调试信息，所以一般情况下PDB文件是在Debug模式下才会生成。

- pdb主要适用于汇编代码与源文件的定位（通过文件名，变量名等）

- 模块(Module)，EXE和DLL都可以称之为模块，因为它们都有自已独立的Stack，所以我们在调试程序时，可以在Call Stack窗口查看到所有调用的Module Name。并且可以右键查看相应模块的ybmol Load Information（ybmol, symbol module），即该模块调用的PDB文件路径的过程。

  每个模块被载入的时候，其相同名字的PDB文件同时被载入。所以Debug模式下，不仅因为代码没有优化，同时因为要载入PDB文件，所以Debug模式下的程序执行速度非常慢。

- PDB文件中记录了源文件路径的相关信息，所以在载入PDB文件的时候，就可以将相关调试信息与源码对应。这样可以可视化的实时查看调试时的函数调用、变量值等相关信息。模块当中记录的PDB文件是绝对路径。所以只要模块在当前电脑上载入，调试器自然地会根据模块当中的路径信息找到相应PDB文件并载入。同样PDB文件中记录的源文件路径也是绝对路径，所以PDB文件只要在当前电脑上载入，调试进入相应模块时，都能够匹配到记录的源文件，然后可视化地查看相应信息。

# 相关文件

- [CMake语法及特性相关](C:\Users\CARRYCHOU\Desktop\CMake相关.md)
- [工具生产力指南](C:\Users\CARRYCHOU\Desktop\工具生产力指南.md)
