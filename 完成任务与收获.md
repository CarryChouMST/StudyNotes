# 已完成任务与收获

- 夹点基类调整和墙体夹点方案设计与实现，多堵墙的显示，拖动逻辑，墙体datum约束逻辑，高亮/预览中加定位线，处理bug

- 通用消隐方案设计和实现，路径解析、生成、建模，带指针内容数据结构拷贝构造、赋值和析构的设计，提高接口的防护性（去重、过滤）和复用性

- 通用连接框架设计和实现，析构为虚函数（有可能是子类的对象基类的指针在析构），构造为公开非虚函数，基类权限为protected。一些典型需要复用的方法可以抽取一个Helper保证基类的逻辑存粹性。对于有指针作为成员变量的类需要高度注意，从里面拿到的指针的生命周期由谁管理，如果由自己管理，则只开放const获取接口，如果由外部管理，则再内部单开一个指针的set和get接口（或者通过构造函数），保证外部拿到的是拷贝体。

- 在通用连接框架基础上适配非系统构建的默认连接

- Route数据的存储与加载重构，存储时只存储持久化的必要数据与标记，加载时加一层业务解析；在处理数据逻辑时基于对象的思想，比如只存标记，由对象解析标记提供几何；操作数据最好在一个位置操作；在松耦合后需要对数据有较好的封装，某些类的某些方法只为特定对象使用，同时底层封装可以保证基础逻辑的完整，便于后面修改

- 建模错误信息返出，区分系统错误与非系统错误，在做数据时需要考虑到数据的增删改查，即维护的事情，再维护之外，优先需要利用消息中心做好系统下限的保证，即**有效处理非系统错误**。做一项很大的业务时，由于操作来源还是解空间太大，有些东西需要在架构层面手动区分，比如一个东西发生错误后可以做哪些行为，目前规定一定是有一些东西需要被删除（可以为空），不做修改等其他的维护。

- 连接信息维护，在操作中产生的一系列数据最好通过上下文处理，在统一的地方修改数据。在写一段复用率和耦合度比较高的大型业务操作时，考虑添加多个操作策略以灵活应对不同场景下使用的需求

- 连接重构：一套类的体系构建主要是为了可扩展性较强的骨架算法，是模板方法的设计模式；而一套大流程下的高内聚，可复用性比较强的公共方法可以抽取放在一个helper类中，然后在helper中对主体派生体系做一个友元，这样能在类派生体系中更加清晰的看到主体逻辑，实施细节放在helper中；另外helper里面的工具方法为了做一个低耦合高内聚的模式，当输入比较复杂时，需要将其封在一个inputInfo的结构体内，后面外部使用时只需要适配inputInfo就行。同理，在由多个杂乱入口入一个共同的逻辑时，要慢慢将信息收集做抽象，注意做有效的抽象，比如入口可能为当前、已存在的，在执行端接逻辑前，将其适配成基体主路径和支撑体路径等更加抽象，但针对端接逻辑更加直观的概念。总的来说，写一套派生逻辑时，一般要写一个define文件，专门放一些结构定义、写一套派生.h和.cpp文件，写一个放高内聚，可复用的模块逻辑helper，注意方法放在private并加友元，实施严格的权限管理。

- 消隐重构，对于需要由很多自定义的数据结构时，自己抽取一套define逻辑，define文件也可以放一些简单的上下文类，包括get,set方法；写一个接口时，先想这个接口是跟什么相关，如果跟派生体系某个基类强相关，放在里面static，如果是一个从数据结构设计上较为通用的接口，放在server上，写算法先写股价。如果考虑到扩展性，则将其封装为一个模块，以责任链模式注册使用。另外要注意指针生命周期的管理，如果get接口给的是源数据，则加const，不让外部修改，自己管理；如果要放开权限，则注意get和set接口都给出拷贝体。==另外，在写创建时要考虑维护，维护要考虑数据变更有可能有哪些入口，包括操作上的夹点、属性面板、通用命令（重生成代理操作的数据变更），还要考虑到undo/redo系统和保存加载系统时的InOut操作。==

- 非系统构件建模重生成框架：在处理数据时有两个需要区分的概念，一个是负责来处理的对象manager，比如路径的首节点；第二个影响具体要处理的逻辑/对象的信息/对象，比如路径的尾部节点provider。

- modifiedLevel；对于一个事情存在几种不同的模式A, B, C，且ABC之间存在覆盖等级关系，对于这种情况，考虑level的枚举，枚举中定义几个不同的等级，在更新时，高等级可以覆盖低等级。比如在bim业务中，一个obj被修改可以是仅仅为了显示的关系建模修改，可以是有滞后业务的基本建模修改，这种情况下定义一个枚举ModifiedLevel，然后顶一个结构体referenceModifiedMap=是std::unordered_map\<Objectid, modifiedLevel\>，后面不断的upd。

- 更新连接的优化，在n2的复杂度下尽可能的将流程中间数据通过缓存复用优化，将子流程优化至O(n)，写代码要用算法优化意识，提高代码和数据复用率能便于维护和管理，更能提高性能。

- 各种编辑操作下连接和消隐信息的维护，整个重生成是一个以责任链模式组装而成的大处理器处理不同场景下的重生成请求，在代理build时选用在该次请求中涉及到的处理器，并基于StepList装配好每个子处理器且维护处理器间的输入输出关系，有每个子处理器自定义处理逻辑以及输出是否影响整体结果。Db数据只负责存储（持久化，需要唯一定位）和传输，Db数据随业务需求变更由Db数据的代理完成，在Db层只能由Db数据的代理自己操作自己代理的数据。

- 碰撞检测的优化，空间金字塔的建立，以不同的分辨率尺度划分拓扑图形.**首先将碰撞连通图定义为以构件为节点，以构件AABB盒是否碰撞为边的无向图；然后在构件概念的基础上，推广出n阶构件，将其定义为n-1阶构件的碰撞连通图，对应AABB盒则定义为内部所有n-1阶构件AABB的外框；之后基于以上概念构建碰撞金字塔，金字塔中以构件的阶数作为不同层的分辨率。**

- 碰撞检测优化的维护，包括异常情况的处理，undo/redo的适配，跨文档、跨pc端的支持

- 预览重生成错误数据的及时硬/软处理，

- 梁的连接适配

  >  在genActor的查找中，一些根据不同对象的属性有不同的简单逻辑/返出不同的映射对象，这类if else问题，最好将其转变为注册一系列key-value键值被存储，然后将if else逻辑转变为查找逻辑，可以更方便的进行异常定位，和逻辑修改。
  >
  > 上下文面板中使用ContextPanelManagaerImpl单例管理文档中的上下文面板，单例类和全static工具类的区别在于，单例可以存一些私有成员变量表示改单例全局的属性内容，它里面除了防止一些存粹的工具方法之外，还可以做一些**全局实时**数据逻辑的管理与执行，可以把他理解为**作用域受到限制(不导出则只能作用于当前模块)、有规定起始记录时机（初始化）的全局上下文**。

- 多对象共点约束设计，视野要看的与上面的人一样宽，在做东西前还是要线简单写一下骨架流程，这个流程一方面对要做的事情的梳理，另一方面也方便与其他人交流，这个与自己做完后重新整理的详细笔记还不太一样。写东西前先写粗粒度的几个重要part（比如分组信息的存储和维护），然后考虑这些part与哪些数据有关（connection），分别涉及到几个重要的子项（时机，接口/数据结构，维护方式）

- 修改缓存视图路径的结构，定好接口，树本质上就是一个带有成员孩子指针的根节点，可以根据业务需求让这个节点Node类提供一些接口，比如添加孩子，状态管理，在管理的接口中由他去做一些事

  > 在Unified23dDocViewImp中如果在刷ctp中发现当前源ref没有对应的ctpRef，会调用Unified23dDocView的接口同时直接创建createCounterpart和reference，因此在ctp中目前DO没有得到复用，另外，在create之前会调用atom的shouldCreate接口，因此可以走创建接口但不创建东西，在外面后续刷ctp中，如果ctpId为空，则表示不需要副本显示，返回ok就行。因此在写一个抽象的大流程时，流程中可以有一些check和should接口，后续的流程要注意上一个流程下某些结果为空的问题。

- 类的概念要清晰一些，类要清晰知道类的方法是谁在用，有一些方法的对象属性比较重，放在类的成员方法里面，比如topo里面算step的权重；有些方法的上下文属性、工具属性比较重，有很多相关的/非派生的对象都在用，将其放在工具方法里面。

- clean方法主要要注意两个方面：一是指针生命周期的释放；二是容器的清空。、

- 消隐ctp的mdb适配和重构，如果有一个接口传Id穿不进去（因为id不能被重复打开），尝试传Id下的某个模板的代理管理器，比如atom很重，为了突出骨架算法，封住细节，底下有一个ctpUpdManager，mgr自己又带有updCtx和pfmctx接口。

- 重构db
  - 做事情要对象化，粗粒度化，如果一个事情比如建模，给定一个输入后，有很多依赖于这个输入的特有逻辑，就包装一个特有的上下文来做这个事，外界感知不到里面的事。**接口隔离原则(ISP)**，和**迪米特法则(LOD)（**对象应当对其他对象尽可能少的了解
  - 各个模块之间相互调用时，通常会提供一个统一的接口来实现**）**
  - 有一些内部核心数据结构只是为了帮助上层来管理特有的数据，里面只写set和get接口，数据逻辑的组装全部由上层来组装，底下提供接口读写数据，上层真正的管理这些数据的用途，比如element用来记录数据，ctpAtom用来显示数据。
  - C++的封装特性，将类对象化，关注外部视角下类的表现；可以有一个专门的数据管理类，内部方法类，和外部公开方法类；在底层封db读写接口，上层写逻辑组装。
  - 对于内核数据如driver，有很多上层结构再用，但又不想过于暴露，中间可以通过工具类的方式加一层数据逻辑组装层，各个上层结构用的时候，通过数据逻辑组装层用，不要接触到里面。

- Db一般用于对象的持久化数据缓存，该缓存存在于整个Db模块的生命周期；有时需要在一次业务范围内缓存一些query和match数据，可以构建了一个单例对数据进行管理（单例实际上是限制作用域的全局上下文），并提供clear方法，在一次业务结束后调clear方法清除掉缓存的业务查询数据。

- 对于数据相互依赖的匹配逻辑，如果是该匹配逻辑完全与类型相关，才直接使用虚接口赋予子类完全的控制权；如果有些概念与类型无关，可以抽象为系统枚举标记，尽量抽象为系统标记，在虚接口的上下文中传入该标记（或者是在基类中解析），那在基类中就能把事情干完。

- 线性构件逻辑对象，行为和id的抽象

  > 对于一个抽象层级较高的类，比如线性构件，可以在里面做一个私有数据管理类，在该数据管理类中只提供get, set方法。然后对外有一个Util/Helper/或者其他类处理线式的数据逻辑，在里面中，涉及到复杂的创建过程（或者容易变化的东西），可以使用工厂类进行封装。
  >
  > ==工厂/manager(可能要缓存)创建$\to$对外的业务逻辑类（可以是一个抽象逻辑上的Helper/Util，也可以是一个具体的对外对象）$\to$私有的数据管理类== 
  >
  > 在进行数据设计时要分层设计，每层在对外类中提供给上一层看到的内容，可以是类的组合（墙与线性构件），或者某个抽象层次的类（element）。
  >
  > 有新的需求进来时，判断场景入口，如果入口很多，且过于业务不适合放在生成kernel层，则在出口connectionActor执行逻辑满足需求。

- 线性构件容差功能嵌入到连接框架

- 非系统构件约束流程设计

- 兼顾用户意图与系统推断的自动点约束构建流程

- 梁上下文面板命令类型切换不成功调试。

  > - 在画类的UML图时，可以使用虚线空箭头标识类的==继承关系==，使用实线标识类的==生产关系==
  > - 通过工厂/Creator/Manager进行复杂对象的创建，将对象的创建和功能实现解耦。如果有派生复用的需求，在工厂/Creator/Manager的基类基于不同的标识符进行统一注册(或者RTTI反射)便于管理。manager/工厂等可以提供注册方法，然后将已注册的内容放到自身的成员变量进行管理。

- 调试创建/编辑workFlowJob进入时的上下文面板根据选择集的显示和不显示区别，有些接口（比如面板的startUp）是一个公共的工具接口，接口里面的内容是一个高复用的逻辑，在要修改接口内内容时，首先要想到是不是直接属于这个接口代表的概念，如果是上下文业务上的概念(比如根据选择集判断要不要唤起)，优先考虑在接口外面做，因为调这种工具接口的地方会有很多，不是所有的东西都有这个概念，而且有的地方可能会有冲突的（比如就是要选择集大于1才能进入），handler是外界定制化该接口的途径之一，但是handler本身也是复用率比较高的，对于比较独立的业务需求，应该在最开始这个接口的位置就体现出这个差别。

- 纯虚函数一般只有一个位置调。

- 【将约束放到连接维护框架】要基于产品的业务常见和总体架构设计，根据复用频率和依赖关系积极做分层依赖和dll拆分，进而将代码松耦合，有较强的扩展性。比如在前后端分离下，需要有一层后端数据库pcdb，表示不依赖于客户端的纯数据；在客户端内存上做业务时，需要有一个内存持久化数据BmDatabase；考虑到持久化数据为了存储对数据做了很多拆分、优化、复用，在做业务时需要有与业务语义更相关的数据，因此诞生了docItem，viewItem等item代理数据层，他们两个没有太多的关系，因此拆成了两个dll。现在是考虑到文档数据中有一些通用业务需要维护，因此在doc和docitem之间可以做一个connectionActor层。

- 【重构多对象共点约束】【层间架构思考】怎么定义逻辑属于数据上的，还是属于文档上业务

  - 对于一个发布后的产品，在修改持久化数据时一定要注意版本控制，后一个版本的逻辑要能兼容前一个版本的数据，具体来说，可以给一些默认值等。比如在connection中添加了一些属性，在使用该属性的代码中需要给该属性添加一个老数据能使用的默认值。

  - > - 首先逻辑都是由需求定义的，数据可被区分为持久化数据(pcdb)和内存临时数据(itemDb等)，两种数据在内存架构中都称为数据。
    >
    > - 数据本身会根据自身的概念提供一些小颗粒度能力（比如get/set接口），在对外接口中也可以做一些更大颗粒度的封装（比如一些server等微服务），对于一些非常大的能力，为了保证其灵活性提供一些上下文标记，但是不会脱离其数据的概念，本质上是提供一种能力。==另外数据间的协同也是一种能力==
    > - 来一个需求后，一般需求逻辑都是通过文档业务逻辑对需求解析适配后，组装数据层提供的能力接口（调一个大接口给上下文标记也行/调不同的小接口服务也行）。
    > - 所谓纯数据逻辑就是需求中需要由业务解析的内容比较少，直接使用数据提供的某种颗粒度能力就能满足需求。
    > - 判断一个逻辑属于业务还是数据首先就看这种逻辑是不是一种通用能力，如果是通用能力就由数据提供，如果是当前需求需要的特定效果就在文档业务层组装数据接口。
    > - 持久化数据为了优化持久化性能会对数据做一些拆分和重组，在内存中执行逻辑时可以做一个新的代理层，也就是docItem，可以让docItem提供一些能力。

- 【构件加载更新调试】写业务逻辑代码时，不仅要考虑业务场景下逻辑的松耦合分层设计；更要考虑产品整体数据架构云边端的设计，对于非系统构件这种开放给用户的，做成一个高内聚的设计，同时对于非系统构件内部的私有属性、表达数据，尽量不要记录在设计上记录构件之外的信息，因为不知道用户会在里面做什么，也就无法修复，直接替换。

- 【夹点以及交互editor的设计思考】对于外观模式的使用，外观类提供非核心，语义更强，对外可见的逻辑和变量；核心逻辑以及变量，可以单独做一个impl类进行管理。然后在外观类的构造函数中new其实现类，析构函数中释放。这样用不同的类管理也便于面向对象的理解逻辑组成。

- 【约束适配到框架】==做事情优先从抽象的方式做，做完了在性能优化阶段中再考虑性能和扩展性的平衡==。难点：需要在各种场景下建立合适的约束，需要识别对应的场景，参与关系的构件/非构件（纯几何）【在关系中只有几何没有构件的概念，需要理清构件业务接口和纯几何接口，比如现在有一个逻辑几何，要去拿逻辑几何上有没有其他的关系，这个应该脱离了构件的概念，需要几何上的接口。但是目前线性构件是在构件上做了抽象，还没有抽象到几何级】，匹配关系的类型。

- 数据直接修改接口（为了数据的提供），内部模块组装imp，外部语义接口（为了模块的封装，模块内和模块外得到的信息不一样）

- 【带团队与沟通】让成员自己单独推进事项，独立负责

  - 自己有精力处理困难的任务，帮助团队获得更多的资源
  -  通过独立负责锻炼成员的全流程解决能力
  - 通过独立沟通与汇报帮助成员在+2领导有更多的表现机会，+2领导可以更好的把握人员情况
  - 拿到需求，首先需要对需求做评估，从五个方面：需求的必要性（描述场景）、正确性（是否和架构目标匹配，前后端分离...）、合理性（交付时间下，是否出现研发团队和动作完全变形的情况）、可达性、承接方（有没有团队能承接、愿意承接）（必正合可乘）
  - 然后对需求做需求分析：理解业务（没有歧义的拆分各个功能点），识别重难点业务，识别非功能需求和质量约束（比如性能，扩展性，可靠度），给出基本业务架构

- 【调试、运维、工具和脚本能力】大型项目的模块调试、松耦合（载入代码）调试和附加进程等调试经验，编写批处理、python脚本处理工程部署的运维和调试需求，比如在release下写脚本批量关闭所有模块优化后，高速调试等。

- 【db数据的优化】广义的生命周期包括对象生命周期、权限管理、版本控制、状态流转等，可以通过策略进行配置。一个db主要是为了更好的管理对象的生命周期，而要将数据持久化，需要后端提供IO流接口，不一定所有的db数据都需要被持久化。

- 【预览机制的优化】可以通过线程同步的方式，实现流程间的通信，对于一些高复杂度操作优化体验时，可以做个简易版，然后以异步的方式做一个完整版，可以实时根据操作频率优化体验

- 【预览优化对于构件的适配】在前后端分离的C/S架构模式中，**前后端的数据流转方式**对项目产品整体性能很重要，一般是是**通过数据对象链接的方式，实现按需的加载/卸载**，这样能减少C端的内存压力和负载，将构件实例、构件类型模板、类型定义数据作为不同层级的数据对象，不同环境下编辑不同层级的对象（比如构件定义环境编辑数据定义对象，构件编辑器环境编辑模板数据，项目环境编辑实例数据）。不同层级的数据都被聚合于文档根对象中，后端将根对象加载。

  ~~~cpp
  ### 1. **内存效率**
  
  - **减少冗余数据**：通过链接，多个对象可以共享同一个数据对象，避免了数据的重复存储。
  - **延迟加载**：可以只在需要时才加载和初始化数据对象，节省内存。
  
  ### 2. **提高性能**
  
  - **快速访问**：通过指针或引用可以快速访问关联的数据对象，而不需要进行复杂的查找或复制操作。
  - **节省处理时间**：避免了不必要的数据复制操作，可以显著提高程序的运行速度。
  
  ### 3. **更好的可扩展性**
  
  - **动态修改**：可以动态地添加、删除或修改数据对象及其链接关系，而不需要重新分配和复制大量数据。
  - **模块化设计**：数据对象的链接方式支持模块化设计，使得程序的结构更加清晰，易于维护和扩展。
  
  ### 4. **数据一致性**
  
  - **共享更新**：当数据对象被多个地方引用时，更新其中一个对象的数据，所有引用该对象的地方都会同步更新，保持数据一致性。
  - **集中管理**：可以集中管理和控制数据对象的生命周期和状态，减少数据不一致的问题。
  
  ### 5. **增强灵活性**
  
  - **多态性和继承**：在面向对象编程中，通过基类指针或引用，可以实现多态性，处理不同类型的对象而无需知道它们的具体类型。
  - **松耦合**：对象之间通过链接进行通信和交互，而不是直接依赖于具体的实现，使得系统更具灵活性和可维护性。
  ~~~

- 【重生成执行流程梳理，性能优化】如果软件运行时间长后出现明显的卡顿，考虑内存泄露。另外有可能是由于运行时间长后，系统中内存分布趋向碎片化，难以找到整块内存（查找时间）。
  - 另外对于有向图中如果边的数量远高于节点的数量，同时有频繁的查询需求，可以考虑将有向图的连通分量进行缓存，从而将递归查询需求映射为整块分量。
