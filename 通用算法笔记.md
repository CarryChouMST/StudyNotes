# C++基础篇

## 语法

### 初始化

- 对于内置类型变量（如int，double，bool等），如果定义在语句块外（即{}外），则变量被默认初始化为0；如果定义在语句块内（即{}内），变量将拥有未定义的值。

- 对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。[原文链接](https://blog.csdn.net/cclethe/article/details/129786356)
- array<>是唯一一个无任何东西被指定为初值时，会被预初始化的容器。这意味着对于基础类型，初值可能不明确，而不是0，例如：下面定义一个有妖妖灵个int元素的数组arr。
- 在赋值过程中最容易误解的地方是误以为以下代码将a5全赋值为1。
  char a5[3] = {1};  //这行代码之后，数组a5各项值分别为1, 0, 0。
  这是因为在C/C++中，“如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为0。”因此我们便可以通过int a2[3] = {0};来将数组a2全赋值为0。[原文链接](https://blog.csdn.net/lanceleng/article/details/8707745)
- fmod()与求模运算符%的对比
  - % 只用于整型的计算，后一个数不能是0，参与运算的数据可正可负。
  - fmod()函数可以对浮点型数据进行取模运算，后一个数可为0，这时函数返回NaN。

### 字符串

- string 类有一些查找子串和字符的[成员函数](https://so.csdn.net/so/search?q=成员函数&spm=1001.2101.3001.7020)，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。如果查不到，则返回 string::npos。string: :npos 是在 string 类中定义的一个静态常量。
- C++提供的string字符串支持索引取值。
- find：从前往后查找子串或字符出现的位置。如果找不到会返回string::npos.
  rfind：从后往前查找子串或字符出现的位置。
  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：s1.find_first_of("abc");  //查找s1中第一次出现"abc"中任一字符的位置
  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。
  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。
  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。

### 标准库std::array

- 优点：
  - **类型安全**：std::array是一个类模板，类型安全比传统的C风格数组更强。
  - **接口一致性**：提供了size(), at(), begin(), end()等、
  - **与STL兼容**：兼容STL里面的算法和容器，可以直接传递给std::sort等STL算法。

## 基础算法与数据结构

- 散列表
  - 构造哈希映射， 可以用链地址法，std::vector\<list\<pair\<int, int\>\>\> data;
- 堆与二叉搜索树的区别
  - 数据有两种基本的存储结构，顺序存储和链式存储，前者节省空间，索引访问；后者需要有额外的指针空间，链式访问。堆作为**完全二叉树**，可以使用前者存储；二叉搜索树则需要采用后者。
  - 时空复杂度类似，但是二叉搜索树容易退化为链表，从而变为O(n)。因此发展出了红黑树，AVL等更平衡的树。
  - 二叉搜索树建树时隐含了去重的逻辑，堆允许重复元素。
  - 二叉搜索树服务于查找，无法在不额外排序下进行逻辑取值（链式存储，根节点在中心处，要取到最小/最大值也需要logn），但是可以快速按键取值；堆可排序，可逻辑取值，但无法查找。同时堆的高度一般比二叉搜索树要低，查找之外的操作比如插入等复杂度常数项比BST低。
  - 堆排序是建立在堆上的选择排序。
  - 要始终维护有序数组，如果存在有序重复的可能性，使用二分插入。不能使用map
- 哈希表与红黑树等兼顾排序与去重的map（自平衡BST）优劣
  - 哈希表的复杂度为O(1)，高效存取，红黑树为lg(n)。且红黑树为了优化对有序集排序的退化问题，常数较大。
  - 哈希表相对红黑树而言需要的内存空间更大。
  - 红黑树是有序的，Hash是无序的，根据需求来选择。
  - 红黑树占用的内存更小（仅需要为其存在的节点分配内存），而Hash事先应该分配足够的内存存储散列表,即使有些槽可能弃用
  - 红黑树查找和删除的时间复杂度都是O(logn)，Hash查找和删除的时间复杂度都是O(1)。
- 哈希表、堆、BST、自平衡BST：
  - 哈希表按键取值，堆逻辑取值（lgn较为稳定，完全二叉树，占用空间小，但没有按键取值的能力），BST与红黑树在堆上扩展了按键取值能力（lgn），但是占用了更大的空间（不完全二叉树），且红黑树为了维护树的平衡性能不稳定。

### 排序

- 【插入排序与归并排序】
  - 插入排序的最好时间复杂度是O(n)【已经有序的情况下扫一遍】，最坏是n2，但是常数较低
  - 归并排序的均摊是O(nlogn)，但是最好也还是需要O(nlogn)，不断合并有序表，比较好的做法是归并分组+插入排序。‘

- 【冒泡与插入】冒泡排序与插入排序的区别是，插入排序的比较更为直接，对于部分位置正确的元素，插入排序能尽早的识别并剪枝，而冒泡排序总需要比较所有有序对。（节省了比较耗时）

## 拓展算法

- 前缀和（trim）
  - 前缀和非常适合提取区间信息做区间查询。

# 算法刷题经验

- 【字母异位词】：对于字符串的排序，由于已知上下界，可以使用计数排序O(n);
  可以定一个匿名散列函数，然后使用decltype提取类型就能作为std::unordered_map的散列模板；
  最长连续序列：已知信息是一个数组，目标是一个有序的序列。使用精准度更高的信息（按阿拉伯顺序），拿到一个数不断查询+1数是否存在。

- 将所有为0的移到后面，且保持顺序：双指针交换
  盛最多水的容器：双指针移动，有多个变量，确定一个极值然后梯度下降。如果有多个极值随机选择一个即可，如果存在最优解，在每次迭代中自然会滑到那里。（比如两个相等，到时候碰到会相互移动。）

- 三数之和：**对于子数组查询结果（一个大数组内，有多少子数组结果组合）需要去重的，一般考虑先排序，利用有序性去重。然后固定其中一个数，剩余转化为使用哈希表或双指针的两数之和。（经实验hash后也需要根据idx去重，而且会找到指针已经走过的信息，没有双指针复杂度常数项低）。
  ​在C++中int和size_t比较时，根据类型自动转换规则，int会被首先转换为unsigned int。如果int值为-1，会被转换为4294967295（int一般是-2147483648~2147483647）。因此，如果在循环中确实想用int类型，有可能为负值时，获取线性表长度后，强制转为int一下。比如int len = nums.size();

- 接雨水：对于类似需要匹配括号、匹配类似区间等这种类似嵌套匹配的情况，都可以考虑使用栈，出站过程可以模拟逐层接水。
  对于类似短木桶场景的求容积题目，一般可以考虑双指针移动较小值，考虑到对于一格柱的出水取决于两侧区间的最高值中的较小值【**始终移动较小值可以保证两个指针中的较大值是当前的极大值**】。对于端侧指针，对侧移动后对于端侧区间是完全可控的，更新后根据指针新值与对侧原值的大小确认是否更换两侧区间最高值，从而更新较小侧中指针的取水值。
  while (l < r){get Maxl; get MaxR; if (curL < curR) {}else {}}

- 最长连续子串：string可以直接索引取值，也有find方法。滑动窗口可以使用for while组合，while为哨兵指针。

- 找字母异位词：对于有序子串的寻找可以使用滑动窗口，使用for while框架，默认从-1开始滑动。定义好哨兵指针的停止移动条件和后排指针的移动效果（注意过滤出-1不做任何处理。）
  for (i;i<len;++i){if (i!=0){xxx}  while (rk + 1 < len && 停止移动条件的补集){移动处理}}
  标算：滑动窗口可以是定长窗口或变长窗口，对于找异位模式串可以使用定长窗口，维护差值变量。
  妙算：也可以是哨兵为for一直往前走，后排收缩。

- 合为k的子数组：在数组非有序的情况下，要复用区间和结果，此时不能简单的直接使用滑动窗口（因为存在有正有负，无法确定哨兵指针终止滑动条件）。可以先使用前缀和预处理数组，这样就能以O(1)的时间得到中间区间的和。
  最后可以变为一个以i为结尾的子串中能找到的合为k的数量（问题拆解为子问题）。
  注意在基于前缀和数组求两数差得到中间区间和时，一般要在前面虚拟一个0节点，这样可以以统一的求差得到一个从起始节点开始的完整区间。

- 如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况下，0x7fffffff并不是一个好的选择。最精巧的无穷大常量取值是0x3f3f3f3f，无穷小常量取值0xc0c0c0c0（-1061109568）。
  如果是int，用INT_MAX表示正无穷，INT_MIN表示负无穷，需要包含头文件limits.h；
  如果是double，用DBL_MAX表示正无穷，DBL_MIN表示负无穷，需要包含文件float.h。

  【滑动窗口中的最大值】实时维护最大值，首先想到堆/优先队列，由于队列只能处理头部元素，需要判断头部元素是否在滑动窗口中，可以使用索引判断。
  查询有逻辑查询和按值查询，逻辑查询考虑优先队列

