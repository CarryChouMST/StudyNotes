# C++基础篇

## 语法

### 初始化

- 对于内置类型变量（如int，double，bool等），如果定义在语句块外（即{}外），则变量被默认初始化为0；如果定义在语句块内（即{}内），变量将拥有未定义的值。

- 对于类类型的变量（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数，则会引发错误。因此，建议为每个类都定义一个默认构造函数（=default）。[原文链接](https://blog.csdn.net/cclethe/article/details/129786356)
- array<>是唯一一个无任何东西被指定为初值时，会被预初始化的容器。这意味着对于基础类型，初值可能不明确，而不是0，例如：下面定义一个有妖妖灵个int元素的数组arr。
- 在赋值过程中最容易误解的地方是误以为以下代码将a5全赋值为1。
  char a5[3] = {1};  //这行代码之后，数组a5各项值分别为1, 0, 0。
  这是因为在C/C++中，“如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为0。”因此我们便可以通过int a2[3] = {0};来将数组a2全赋值为0。[原文链接](https://blog.csdn.net/lanceleng/article/details/8707745)
- fmod()与求模运算符%的对比
  - % 只用于整型的计算，后一个数不能是0，参与运算的数据可正可负。
  - fmod()函数可以对浮点型数据进行取模运算，后一个数可为0，这时函数返回NaN。

### 字符串

- string 类有一些查找子串和字符的[成员函数](https://so.csdn.net/so/search?q=成员函数&spm=1001.2101.3001.7020)，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。如果查不到，则返回 string::npos。string: :npos 是在 string 类中定义的一个静态常量。
- C++提供的string字符串支持索引取值。
- find：从前往后查找子串或字符出现的位置。如果找不到会返回string::npos.
  rfind：从后往前查找子串或字符出现的位置。
  find_first_of：从前往后查找何处出现另一个字符串中包含的字符。例如：s1.find_first_of("abc");  //查找s1中第一次出现"abc"中任一字符的位置
  find_last_of：从后往前查找何处出现另一个字符串中包含的字符。
  find_first_not_of：从前往后查找何处出现另一个字符串中没有包含的字符。
  find_last_not_of：从后往前查找何处出现另一个字符串中没有包含的字符。

### 标准库std::array

- 优点：
  - **类型安全**：std::array是一个类模板，类型安全比传统的C风格数组更强。
  - **接口一致性**：提供了size(), at(), begin(), end()等、
  - **与STL兼容**：兼容STL里面的算法和容器，可以直接传递给std::sort等STL算法。

## 基础算法

- 散列表
  - 构造哈希映射， 可以用链地址法，std::vector\<list\<pair\<int, int\>\>\> data;

- 堆与二叉搜索树的区别
  - 数据有两种基本的存储结构，顺序存储和链式存储，前者节省空间，索引访问；后者需要有额外的指针空间，链式访问。堆作为**完全二叉树**，可以使用前者存储；二叉搜索树则需要采用后者。
  - 时空复杂度类似，但是二叉搜索树容易退化为链表，从而变为O(n)。因此发展出了红黑树，AVL等更平衡的树。
  - 二叉搜索树建树时隐含了去重的逻辑，堆允许重复元素。
  - 二叉搜索树服务于查找，无法在不额外排序下进行逻辑取值（链式存储，根节点在中心处），但是可以快速按键取值；堆可排序，可逻辑取值，但无法查找。同时堆的高度一般比二叉搜索树要低，查找之外的操作比如插入等复杂度常数项比BST低。
  - 堆排序是建立在堆上的选择排序。
  - 要始终维护有序数组，如果存在有序重复的可能性，使用二分插入。不能使用map

## 拓展算法

- 前缀和（trim）
  - 前缀和非常适合提取区间信息做区间查询。

